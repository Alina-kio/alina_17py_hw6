a = int(input('enter num between 0 and 1_000_000 with interval 2: '))
class Solution:
    def get_list(sellf) :
        return list(range(0, 1000000, 2))
    def binary_search(self, list, target):
        self.begin = 0
        self.end = len(list) - 1
        while self.begin <= self.end:
            mid = self.begin + (self.end - self.begin) // 2
            mid_value = list[mid]
            if mid_value == target:
                return f'index: {mid}'
            elif target < mid_value:
                self.end = mid - 1
            else:
                self.begin = mid + 1
        return None
sol = Solution()
b = sol.get_list()
print(sol.binary_search(b, a))



c = """
    Целочисленный двоичный поиск
    алгоритма, который последовательно делит пополам заранее отсортированный массив данных, 
    чтобы обнаружить нужный элемент.\n"""
d = """
    Вместо того, чтобы выполнять поиск, просматривая данные в последовательности, 
    бинарный алгоритм случайным образом обращается к данным, чтобы найти требуемый элемент. 
    Это делает поисковые циклы короче и точнее.
    Бинарный поиск выполняет сравнение отсортированных данных на основе принципа упорядочения, 
    чем сравнение на равенство, которое медленнее и в большинстве случаев неточно.
"""
e = """
    1) Процесс поиска начинается с определения местоположения среднего элемента отсортированного массива данных.
    2) После этого значение ключа сравнивается с элементом. Если значение ключа меньше, чем средний элемент, 
    то поиск анализирует верхние значения для среднего элемента для сравнения и сопоставления
    3) В случае, если значение ключа больше, чем средний элемент, поиск выполняет анализ нижних значений для среднего элемента для сравнения и сопоставления."""

with open('binary_search_docs.txt', 'w') as file:
    file.write(f'что такое Binary Search?\n{c}\nзачем нужен Binary Search?\n{d}\nпринцип работы Binary Search\n{e}')